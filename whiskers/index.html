<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Whiskers — Soft Paws</title>
  <style>
    :root{
      --bg1:#0e1630; /* night blue */
      --bg2:#1c2a55;
      --accent:#ffd86b; /* warm star */
      --toy:#ffe27a;
      --crib:#d7d7e0;
      --rail:#c6c6d2;
      --cat1:#f0a35a; /* ginger */
      --cat2:#f7c789;
      --cat3:#e07a3f;
      --ui:#ffffffcc;
      --ui-dim:#ffffff88;
      --shadow:#00000088;
      --danger:#ff6b6b;
      --ok:#64d6a4;
      --warn:#ffb86b;
    }

    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(120% 100% at 50% 0%, var(--bg2) 0%, var(--bg1) 60%);
      color:#fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow:hidden;
      -webkit-tap-highlight-color: transparent;
    }

    #game{
      position:fixed; inset:0;
      perspective: 900px; /* subtle 3D */
      display:grid; place-items:center;
    }

    #scene{
      position:relative;
      width: 100vw; height: 100dvh;
      transform-style: preserve-3d;
      overflow:hidden;
      touch-action: none;
    }

    /* Background wall with sleepy stars */
    .stars{ position:absolute; inset: -10vmax; transform: translateZ(-200px) scale(1.2); opacity:.35; pointer-events:none; }

    /* Parallax baby silhouette */
    .baby{ position:absolute; left:50%; bottom:32vh; width:44vmin; height:22vmin; transform: translate(-50%,0) translateZ(-80px); opacity:.5; filter: blur(.6px); pointer-events:none; }

    /* Crib layers */
    .crib-back, .crib-front{
      position:absolute; left:50%; transform:translateX(-50%);
      width:min(92vw, 820px);
      border-radius: 22px;
      background: linear-gradient(#eaeaf3,#cfd1dc);
      box-shadow: 0 10px 30px var(--shadow) inset;
    }
    .crib-back{ bottom:30vh; height: 18vh; transform: translateX(-50%) translateZ(-40px) rotateX(2deg); opacity:.75; }
    .crib-front{ bottom:8vh; height: 28vh; transform: translateX(-50%) translateZ(80px) rotateX(-3deg); box-shadow: 0 6px 18px var(--shadow); }

    /* Railings via repeating gradient */
    .rails{ position:absolute; inset:0; border-radius: inherit; overflow:hidden; }
    .rails::before{ content:""; position:absolute; inset: 10px; border-radius: 16px; background:
      repeating-linear-gradient(90deg, var(--rail) 0 10px, #eef0f6 10px 18px) ;
      box-shadow: inset 0 0 0 10px #eef0f6aa;
      opacity:.95;
    }

    /* Floor */
    .floor{ position:absolute; left:0; right:0; bottom:-10vh; height:30vh; transform: translateZ(120px) rotateX(70deg); background:
      linear-gradient(transparent, #0a0f25 30%),
      repeating-linear-gradient(90deg, #0f193a 0 4px, #112149 4px 8px);
      filter: drop-shadow(0 -20px 40px #00000055);
    }

    /* Toy string & star */
    .toy{ position:absolute; left:50%; top:6vh; width:5vmin; height:5vmin; transform: translateZ(60px); pointer-events:none; }
    .toy .string{ position:absolute; left:50%; top:-40vh; width:2px; height:45vh; transform: translateX(-50%); background: linear-gradient(#aaa,#ddd); opacity:.7; }
    .star{ width:100%; height:100%; filter: drop-shadow(0 6px 6px #00000055); }

    /* Canvas playfield sits between crib back and front */
    #play{ position:absolute; inset:0; transform: translateZ(0px); }

    /* HUD */
    .hud{ position:absolute; left:50%; top:1.5vh; transform: translate(-50%,0) translateZ(140px); display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:center; z-index:10; }
    .pill{ backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); background:#ffffff14; border:1px solid #ffffff22; padding:8px 12px; border-radius:999px; box-shadow:0 6px 18px #00000033; display:flex; align-items:center; gap:10px; }
    .meter{ width:min(46vw, 320px); height:14px; background:#ffffff22; border-radius:999px; overflow:hidden; border:1px solid #ffffff44; }
    .meter > i{ display:block; height:100%; width:0%; background: linear-gradient(90deg, var(--ok), var(--warn), var(--danger)); transition: width .2s ease; }
    .timer{ font-weight:700; letter-spacing:.5px; text-shadow:0 1px 0 #0005; }

    .btn{ cursor:pointer; user-select:none; border:none; color:#fff; padding:10px 14px; border-radius:14px; font-weight:700; background: linear-gradient(180deg,#4b7bec,#3867d6); box-shadow:0 6px 18px #0006, inset 0 1px 0 #ffffff44; transition: transform .06s ease; }
    .btn:active{ transform: translateY(1px) scale(.99); }
    .btn.secondary{ background: linear-gradient(180deg,#2d98da,#0fb9b1); }
    .btn.warning{ background: linear-gradient(180deg,#ff9f43,#ff793f); }

    /* Overlay messages */
    #overlay{ position:absolute; inset:0; display:grid; place-items:center; z-index:20; pointer-events:none; }
    .card{ pointer-events:auto; max-width:min(92vw,540px); border-radius:22px; padding:22px; background:#09112aee; border:1px solid #ffffff22; box-shadow: 0 20px 50px #0008; text-align:center; }
    .card h1{ margin:.2rem 0 .4rem; font-size: clamp(1.2rem, 4.2vw, 2rem); }
    .card p{ margin:.4rem 0 1rem; color:var(--ui); }
    .row{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }

    /* Zzz bubbles */
    .zzz{ position:absolute; left:50%; bottom: 46vh; transform: translateX(-50%) translateZ(-60px); font-weight:800; font-size:clamp(16px,4vw,24px); color:#ffffffbb; pointer-events:none; text-shadow:0 2px 0 #0006; }

    /* Small helpers */
    .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0; }
  </style>
</head>
<body>
  <div id="game">
    <div id="scene" aria-label="Whiskers—Soft Paws game scene" role="application">
      <!-- distant stars for parallax -3D feel -->
      <svg class="stars" viewBox="0 0 800 600" aria-hidden="true">
        <defs>
          <radialGradient id="sg" r="1">
            <stop offset="0" stop-color="white"/>
            <stop offset="1" stop-color="white" stop-opacity="0"/>
          </radialGradient>
        </defs>
        <g>
          <!-- sprinkle stars -->
          <circle cx="50" cy="80" r="2" fill="url(#sg)"/>
          <circle cx="120" cy="30" r="1.6" fill="url(#sg)"/>
          <circle cx="240" cy="100" r="2.2" fill="url(#sg)"/>
          <circle cx="360" cy="50" r="1.7" fill="url(#sg)"/>
          <circle cx="600" cy="90" r="2.1" fill="url(#sg)"/>
          <circle cx="740" cy="40" r="1.8" fill="url(#sg)"/>
          <circle cx="140" cy="200" r="1.2" fill="url(#sg)"/>
          <circle cx="420" cy="220" r="1.4" fill="url(#sg)"/>
          <circle cx="520" cy="260" r="1.1" fill="url(#sg)"/>
          <circle cx="700" cy="200" r="1.9" fill="url(#sg)"/>
        </g>
      </svg>

      <!-- sleepy baby silhouette -->
      <svg class="baby" viewBox="0 0 300 150" aria-hidden="true">
        <defs>
          <linearGradient id="bg" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0" stop-color="#9db1ff" stop-opacity=".5"/>
            <stop offset="1" stop-color="#5c74c9" stop-opacity=".5"/>
          </linearGradient>
        </defs>
        <g fill="url(#bg)">
          <ellipse cx="80" cy="80" rx="70" ry="40"/>
          <circle cx="130" cy="60" r="22"/>
          <rect x="160" y="60" width="120" height="38" rx="18"/>
        </g>
      </svg>

      <!-- Back crib -->
      <div class="crib-back">
        <div class="rails" aria-hidden="true"></div>
      </div>

      <!-- Playfield Canvas -->
      <canvas id="play" aria-label="Playfield"></canvas>

      <!-- Dangling toy -->
      <div class="toy" id="toy">
        <div class="string"></div>
        <svg class="star" viewBox="0 0 100 100">
          <defs>
            <radialGradient id="gold" cx="50%" cy="40%" r="60%">
              <stop offset="0%" stop-color="#fff7c5"/>
              <stop offset="50%" stop-color="#ffe27a"/>
              <stop offset="100%" stop-color="#f5b642"/>
            </radialGradient>
          </defs>
          <g fill="url(#gold)">
            <path d="M50 5 L61 35 L94 38 L68 58 L76 90 L50 72 L24 90 L32 58 L6 38 L39 35 Z"/>
          </g>
        </svg>
      </div>

      <!-- Front crib -->
      <div class="crib-front">
        <div class="rails" aria-hidden="true"></div>
      </div>

      <!-- Floor -->
      <div class="floor"></div>

      <!-- HUD -->
      <div class="hud" aria-live="polite" aria-atomic="true">
        <div class="pill" title="Baby Sleep Meter">
          <span>Baby Sleep</span>
          <div class="meter" aria-hidden="true"><i id="meterFill"></i></div>
        </div>
        <div class="pill timer" id="timer">00:45</div>
        <button class="btn secondary" id="treatBtn" aria-label="Rattle a treat to lure Whiskers">Treat</button>
        <button class="btn" id="motionBtn" aria-label="Enable motion controls for shaking the treat">Enable Motion</button>
        <button class="btn warning" id="restartBtn" aria-label="Restart the game">Restart</button>
      </div>

      <!-- Zzz indicator -->
      <div class="zzz" id="zzz">Z Z Z</div>

      <!-- Overlay for start/win/lose -->
      <div id="overlay">
        <div class="card" id="card">
          <h1 id="title">Whiskers — Soft Paws</h1>
          <p id="subtitle">Swipe gently to redirect Whiskers. Shake your phone or tap <strong>Treat</strong> to rattle a toy. Keep the baby asleep for 45 seconds!</p>
          <div class="row">
            <button class="btn" id="startBtn">Tap to Start</button>
          </div>
          <p style="opacity:.7; font-size:.9rem; margin-top:10px">Tip: Big swipes and loud rattles make noise. Keep it soft. ✨</p>
        </div>
      </div>

    </div>
  </div>

  <script>
    (function(){
      const canvas = document.getElementById('play');
      const ctx = canvas.getContext('2d');
      const scene = document.getElementById('scene');
      const toyEl = document.getElementById('toy');
      const meterFill = document.getElementById('meterFill');
      const timerEl = document.getElementById('timer');
      const zzzEl = document.getElementById('zzz');

      const overlay = document.getElementById('overlay');
      const card = document.getElementById('card');
      const title = document.getElementById('title');
      const subtitle = document.getElementById('subtitle');
      const startBtn = document.getElementById('startBtn');
      const restartBtn = document.getElementById('restartBtn');
      const treatBtn = document.getElementById('treatBtn');
      const motionBtn = document.getElementById('motionBtn');

      let W=0, H=0, DPR=1; // canvas dims

      const state = {
        running:false,
        over:false,
        timeLeft:45, // seconds
        last: 0,
        noise: 6, // start calm
        toy: {x:0, y:0, phase:0},
        treat: {active:false, x:0, y:0, t:0},
        cat: {
          x:0,y:0, vx:0,vy:0, size: 28,
          facing: 1,
          onGround: true,
          lastJump: 0,
          nextJumpAt: 3 + Math.random()*3,
        }
      };

      // Utility
      const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
      const lerp=(a,b,t)=>a+(b-a)*t;
      const now=()=>performance.now()/1000;
      const rand=(a,b)=>a+Math.random()*(b-a);

      function fit(){
        DPR = Math.min(2, window.devicePixelRatio || 1); // balance sharpness and perf
        W = Math.floor(scene.clientWidth);
        H = Math.floor(scene.clientHeight);
        canvas.width = Math.floor(W*DPR);
        canvas.height = Math.floor(H*DPR);
        canvas.style.width = W+'px';
        canvas.style.height = H+'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
        // place cat on floor, toy at top center
        state.toy.x = W/2;
        state.toy.y = H*0.18 + 10;
        toyEl.style.left = (state.toy.x - toyEl.clientWidth/2) + 'px';
        toyEl.style.top = (state.toy.y - toyEl.clientHeight/2) + 'px';
        state.cat.x = W/2 + rand(-120, 120);
        state.cat.y = H*0.82;
      }
      window.addEventListener('resize', fit);
      fit();

      // Input (pointer swipes -> gentle gusts)
      let pointerDown=false, pStart=null, pLast=null, pTime=0;
      function pointer(e){
        const rect = scene.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        return {x,y,t: performance.now()};
      }
      scene.addEventListener('pointerdown', e=>{ pointerDown=true; pStart=pLast=pointer(e); pTime=performance.now(); });
      scene.addEventListener('pointermove', e=>{ if(!pointerDown) return; pLast=pointer(e); });
      const SWIPE_MIN = 12; // px
      const SWIPE_SCALE = 0.045; // impulse strength
      scene.addEventListener('pointerup', e=>{
        if(!pointerDown) return; pointerDown=false; const end=pointer(e);
        const dx = end.x - pStart.x; const dy = end.y - pStart.y;
        const dist = Math.hypot(dx,dy);
        if(dist>SWIPE_MIN){
          const power = Math.min(1, dist/240);
          // gust pushes opposite to swipe direction, like fanning
          const gx = -dx * SWIPE_SCALE * power;
          const gy = -dy * SWIPE_SCALE * power;
          state.cat.vx += gx; state.cat.vy += gy;
          state.cat.facing = Math.sign(state.cat.vx||1);
          addNoise(6*power + (Math.abs(gy)>2? 2:0));
          pulseZzz();
        }
      });
      scene.addEventListener('pointercancel', ()=>{ pointerDown=false; });

      // Treat button -> rattle and lure
      treatBtn.addEventListener('click', ()=>{ triggerTreat('button'); });

      // Restart button
      restartBtn.addEventListener('click', ()=>{ restart(); });

      // Overlay start
      startBtn.addEventListener('click', ()=>{
        overlay.style.display='none';
        resumeAudio();
        startGame();
      });

      // Device motion (shake to rattle)
      let motionEnabled=false, lastShake=0; const SHAKE_COOLDOWN=0.9; const SHAKE_THRESHOLD=18; // m/s^2
      async function enableMotion(){
        try{
          if(typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
            const res = await DeviceMotionEvent.requestPermission();
            if(res !== 'granted') throw new Error('Motion permission denied');
          }
          window.addEventListener('devicemotion', onMotion, {passive:true});
          motionEnabled=true;
          motionBtn.textContent='Motion On';
          motionBtn.disabled=true;
          motionBtn.classList.add('secondary');
        }catch(err){
          alert('Motion control not available or permission denied. You can still tap Treat.');
        }
      }
      motionBtn.addEventListener('click', enableMotion);

      function onMotion(e){
        if(!state.running) return;
        const a = e.accelerationIncludingGravity || e.acceleration || {x:0,y:0,z:0};
        const mag = Math.hypot(a.x||0, a.y||0, a.z||0);
        const t = now();
        if(mag>SHAKE_THRESHOLD && (t-lastShake)>SHAKE_COOLDOWN){
          lastShake=t;
          triggerTreat('shake');
        }
      }

      // GAME FLOW ---------------------------------------------------------
      function startGame(){
        state.running=true; state.over=false; state.timeLeft=45; state.noise=6;
        state.cat.vx=0; state.cat.vy=0; state.cat.onGround=true; state.cat.lastJump=now(); state.cat.nextJumpAt=rand(2.8,4.5);
        state.treat.active=false; state.treat.t=0;
        state.last = now();
        requestAnimationFrame(tick);
      }

      function restart(){
        overlay.style.display='none';
        resumeAudio();
        fit();
        startGame();
      }

      function gameOver(reason){
        state.running=false; state.over=true;
        title.textContent = (reason==='win'? 'You kept the baby asleep! ✨' : reason==='toy'? 'Uh‑oh! Whiskers got the toy!' : 'Shhh... The baby woke up.');
        subtitle.innerHTML = 'Swipe gently and use <strong>Treat</strong> to lure Whiskers away. Want to try again?';
        startBtn.textContent = 'Play Again';
        overlay.style.display='grid';
      }

      function win(){ gameOver('win'); }

      // NOISE & UI --------------------------------------------------------
      function addNoise(n){
        state.noise = clamp(state.noise + n, 0, 100);
        updateMeter();
      }
      function decayNoise(dt){
        // settle slowly; faster if already calm
        const rate = state.noise>60 ? 2.0 : 4.0;
        state.noise = clamp(state.noise - rate*dt, 0, 100);
      }
      function updateMeter(){
        meterFill.style.width = `${state.noise}%`;
        zzzEl.style.opacity = (1 - state.noise/100)*0.9 + 0.1;
      }
      updateMeter();

      function setTimerDisplay(){
        const t = Math.max(0, Math.ceil(state.timeLeft));
        const m = String(Math.floor(t/60)).padStart(2,'0');
        const s = String(t%60).padStart(2,'0');
        timerEl.textContent = `${m}:${s}`;
      }
      setTimerDisplay();

      // AUDIO -------------------------------------------------------------
      let AC=null;
      function getAC(){ if(!AC){ AC = new (window.AudioContext || window.webkitAudioContext)(); } return AC; }
      function resumeAudio(){ try{ const ac=getAC(); if(ac.state==='suspended') ac.resume(); }catch(e){} }

      function envGain(ac, duration, peak=0.9){
        const g = ac.createGain(); g.gain.setValueAtTime(0, ac.currentTime);
        g.gain.linearRampToValueAtTime(peak, ac.currentTime + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime + duration);
        return g;
      }
      function playRattle(intensity=1){
        const ac = getAC();
        const out = ac.createGain(); out.gain.value=0.7; out.connect(ac.destination);
        // 5–7 quick noise grains + tiny bells
        const grains = 5 + Math.floor(Math.random()*3);
        for(let i=0;i<grains;i++){
          const t = ac.currentTime + i*0.045;
          // white noise grain
          const bufferSize = 2 * ac.sampleRate * 0.1; // 100ms
          const buffer = ac.createBuffer(1, bufferSize, ac.sampleRate);
          const data = buffer.getChannelData(0);
          for(let j=0;j<bufferSize;j++){ data[j] = (Math.random()*2-1) * (0.5+0.5*Math.random()); }
          const src = ac.createBufferSource(); src.buffer = buffer;
          const g = envGain(ac, 0.12, 0.7*intensity);
          const hp = ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 1600 + Math.random()*800;
          src.connect(hp); hp.connect(g); g.connect(out);
          src.start(t);
          // tiny bell
          const o = ac.createOscillator(); o.type='triangle'; o.frequency.value = 1200 + Math.random()*600;
          const gb = envGain(ac, 0.08, 0.3*intensity);
          o.connect(gb); gb.connect(out); o.start(t+0.02); o.stop(t+0.15);
          src.stop(t+0.2);
        }
      }
      function playPurr(){
        try{
          const ac=getAC();
          const o=ac.createOscillator(); o.type='sawtooth'; o.frequency.value=42;
          const lfo=ac.createOscillator(); lfo.frequency.value=24; const lfoGain=ac.createGain(); lfoGain.gain.value=9; lfo.connect(lfoGain); lfoGain.connect(o.frequency);
          const g=ac.createGain(); g.gain.value=0.0001; o.connect(g); g.connect(ac.destination);
          const t=ac.currentTime;
          g.gain.exponentialRampToValueAtTime(0.08, t+0.3);
          g.gain.exponentialRampToValueAtTime(0.0001, t+2.2);
          o.start(); lfo.start(); o.stop(t+2.3); lfo.stop(t+2.3);
        }catch(e){}
      }

      function triggerTreat(source){
        // lure appears at a side away from the cat
        const left = state.cat.x > W/2; // place on opposite side
        state.treat.active = true;
        state.treat.x = left ? W*0.15 : W*0.85;
        state.treat.y = H*0.72 + rand(-40,40);
        state.treat.t = 2.8; // seconds
        playRattle(0.9);
        addNoise(10);
        pulseZzz();
      }

      // Zzz pulse
      let zPulse=0; function pulseZzz(){ zPulse = 1; }

      // PHYSICS & AI ------------------------------------------------------
      const G = 1200; // gravity px/s^2
      const FLOOR_Y = ()=>H*0.82; const CEIL_Y = ()=>H*0.12;

      function update(dt, t){
        // toy swing
        state.toy.phase += dt*0.9; const swing = Math.sin(state.toy.phase)* (W*0.09);
        const toyX = W/2 + swing; const toyY = state.toy.y;
        toyEl.style.transform = `translateZ(60px) translateX(${swing}px)`;

        // treat timer decay
        if(state.treat.active){ state.treat.t -= dt; if(state.treat.t<=0){ state.treat.active=false; } }

        // Cat AI: ground movement towards toy when no treat
        const c = state.cat;
        const target = state.treat.active? {x: state.treat.x, y: state.treat.y} : {x: toyX, y: FLOOR_Y()};
        const dx = target.x - c.x; const dy = (c.onGround?0:(target.y - c.y));
        const desiredVX = clamp(dx*2.2, -220, 220);
        c.vx = lerp(c.vx, desiredVX, (c.onGround? 0.06:0.03));
        c.facing = Math.sign(c.vx || c.facing);

        // jumping logic towards toy if not distracted
        c.lastJump += dt;
        const nearCenter = Math.abs(c.x - toyX) < 120;
        if(c.onGround && !state.treat.active && nearCenter && c.lastJump > c.nextJumpAt){
          c.onGround = false; c.vy = - (680 + Math.random()*120); // jump up
          c.vx += clamp((toyX - c.x)*0.8, -180, 180);
          c.lastJump = 0; c.nextJumpAt = rand(2.8, 4.5);
        }

        // gravity
        if(!c.onGround){ c.vy += G*dt; }

        // integrate
        c.x += c.vx*dt; c.y += c.vy*dt;

        // floor / walls
        const floor = FLOOR_Y();
        if(c.y >= floor){ if(!c.onGround){ addNoise(Math.min(12, Math.abs(c.vy)/60)); } c.y = floor; c.vy=0; c.onGround=true; }
        if(c.x < W*0.08){ c.x=W*0.08; c.vx=Math.abs(c.vx)*0.4; }
        if(c.x > W*0.92){ c.x=W*0.92; c.vx=-Math.abs(c.vx)*0.4; }

        // if cat reaches toy while airborne -> loss
        const dToy = Math.hypot(c.x - toyX, (c.y - 22) - toyY); // approximate head at y-22
        if(dToy < 46 && !state.treat.active){ gameOver('toy'); }

        // approach treat more strongly when active
        if(state.treat.active && c.onGround){ c.vx += clamp((state.treat.x - c.x)*0.12, -100, 100)*dt; }

        // noise natural decay
        decayNoise(dt);
        if(state.noise>=100){ gameOver('noise'); }

        // timer
        state.timeLeft -= dt; setTimerDisplay(); if(state.timeLeft<=0){ state.timeLeft=0; setTimerDisplay(); state.running=false; playPurr(); win(); }

        // zzz pulse decay
        if(zPulse>0){ zPulse = Math.max(0, zPulse - dt*2.5); }
      }

      // RENDER ------------------------------------------------------------
      function drawCat(c){
        const x=c.x, y=c.y; const s = c.size; const faceTilt = clamp(-c.vx*0.02, -6, 6);
        ctx.save();
        ctx.translate(x, y);
        // shadow
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        ctx.beginPath(); ctx.ellipse(0, 10, s*1.1, s*0.45, 0, 0, Math.PI*2); ctx.fill();

        // body
        ctx.translate(0, -s*0.6);
        ctx.fillStyle = '#e58e4c';
        const grad = ctx.createLinearGradient(0, -s*1.1, 0, s*1.2);
        grad.addColorStop(0, getComputedStyle(document.documentElement).getPropertyValue('--cat2').trim());
        grad.addColorStop(1, getComputedStyle(document.documentElement).getPropertyValue('--cat1').trim());
        ctx.fillStyle = grad;
        roundedEllipse(0, 0, s*1.1, s*0.9, 16);

        // stripes
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cat3').trim();
        for(let i=-2;i<=2;i++){
          const yy = i*8 - 6;
          ctx.beginPath(); ctx.ellipse(6, yy, 12, 4, 0.6, 0, Math.PI*2); ctx.fill();
        }

        // head
        ctx.save();
        ctx.translate(c.facing*8, -s*0.78);
        ctx.rotate(faceTilt*Math.PI/180);
        roundedEllipse(0,0, s*0.72, s*0.6, 14);

        // ears
        ctx.fillStyle = '#e58e4c';
        ear(-s*0.38,-s*0.26, -0.6);
        ear( s*0.38,-s*0.26, 0.6);

        // eyes
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.ellipse(-8, -2, 6, 7, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse( 8, -2, 6, 7, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#2a2a2a';
        ctx.beginPath(); ctx.ellipse(-6, -2, 2.5, 5, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse( 6, -2, 2.5, 5, 0, 0, Math.PI*2); ctx.fill();

        // nose
        ctx.fillStyle = '#f4a1a1';
        ctx.beginPath(); triangle(0, 4, 6, 5, Math.PI);
        ctx.fill();

        // whiskers
        ctx.strokeStyle = 'rgba(255,255,255,0.8)'; ctx.lineWidth=1.2;
        for(let i=0;i<3;i++){
          whisker(-4, 6+i*3, -18, 4+i*3);
          whisker( 4, 6+i*3,  18, 4+i*3);
        }

        ctx.restore();

        // tail
        ctx.save();
        ctx.translate(-c.facing* (s*0.9), -s*0.2);
        const wag = Math.sin(performance.now()/160) * 0.3;
        ctx.rotate(wag);
        roundedEllipse(0,0, s*0.9, s*0.25, 12);
        ctx.restore();

        ctx.restore();

        function roundedEllipse(cx,cy, rx, ry, r){
          ctx.save();
          ctx.beginPath();
          ctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2);
          ctx.fill();
          ctx.restore();
        }
        function ear(ex,ey, rot){ ctx.save(); ctx.translate(ex,ey); ctx.rotate(rot); ctx.beginPath(); triangle(0,0, 16,14,-0.1); ctx.fill(); ctx.restore(); }
        function triangle(x,y,w,h,rot){ ctx.save(); ctx.translate(x,y); ctx.rotate(rot); ctx.moveTo(0,-h/2); ctx.lineTo(-w/2,h/2); ctx.lineTo(w/2,h/2); ctx.closePath(); ctx.restore(); }
        function whisker(x1,y1,x2,y2){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.quadraticCurveTo((x1+x2)/2, y1-6, x2,y2); ctx.stroke(); }
      }

      function drawScene(){
        ctx.clearRect(0,0,W,H);
        // optional faint vignette
        const g = ctx.createRadialGradient(W/2,H*0.4, 30, W/2,H*0.4, Math.max(W,H)); g.addColorStop(0,'rgba(255,255,255,0)'); g.addColorStop(1,'rgba(0,0,0,0.20)');
        ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

        // draw cat
        drawCat(state.cat);

        // draw treat lure if active
        if(state.treat.active){
          ctx.save(); ctx.translate(state.treat.x, state.treat.y);
          const t = (state.treat.t%1);
          const r = 16 + Math.sin(performance.now()/120)*3;
          ctx.fillStyle = 'rgba(255,231,140,0.95)';
          ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
          ctx.fillStyle = 'rgba(255,200,80,0.65)'; ctx.beginPath(); ctx.arc(0,0,r*0.6,0,Math.PI*2); ctx.fill();
          ctx.restore();
        }

        // stir effect on crib (flash when noisy)
        if(state.noise>70){
          const alpha = clamp((state.noise-70)/40, 0, 1)*0.35;
          ctx.fillStyle = `rgba(255,90,90,${alpha})`;
          ctx.fillRect(W*0.2, H*0.36, W*0.6, H*0.35);
        }

        // floating Zzz
        const lift = (1 - state.noise/100) * 6 + (zPulse>0 ? -6*zPulse : 0);
        zzzEl.style.transform = `translateX(-50%) translateZ(-60px) translateY(${lift}px)`;
      }

      function tick(){
        if(!state.running) return;
        const t = now(); const dt = Math.min(0.033, t - state.last); state.last=t;
        update(dt,t);
        drawScene();
        requestAnimationFrame(tick);
      }

      // initial accessibility announce (keep overlay visible)

    })();
  </script>
</body>
</html>
