<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Whiskers: Don't Wake the Baby</title>
  <style>
    :root {
      --bg: #0e0f14;
      --fg: #e6e6e6;
      --accent: #7dd3fc;
      --danger: #f87171;
      --success: #86efac;
      --panel: rgba(255,255,255,0.06);
      --panel-strong: rgba(255,255,255,0.12);
    }
    html, body {
      margin: 0; height: 100%; background: var(--bg); color: var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell;
    }
    #wrap { position: fixed; inset: 0; display: grid; grid-template-rows: 1fr; }
    #game { position: relative; overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; }

    /* HUD */
    .hud { position: absolute; inset: 0; pointer-events: none; }
    .topbar { position: absolute; top: env(safe-area-inset-top, 12px); left: 12px; right: 12px; display: grid; grid-template-columns: 1fr auto; gap: 8px; }
    .bar, .chip { background: var(--panel); border-radius: 999px; box-shadow: 0 6px 20px rgba(0,0,0,0.25), inset 0 0 0 1px var(--panel-strong); }
    .bar { height: 14px; overflow: hidden; }
    .bar > .fill { height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), #a78bfa); transition: width 140ms ease; }
    .bar.danger > .fill { background: linear-gradient(90deg, var(--danger), #fb923c); }

    .chip { pointer-events: auto; display: inline-flex; align-items: center; gap: 8px; padding: 10px 12px; font-weight: 600; }
    .chip button { all: unset; cursor: pointer; padding: 8px 12px; background: var(--panel-strong); border-radius: 14px; }
    .chip button:active { transform: translateY(1px); }

    /* Center overlays */
    .overlay { pointer-events: auto; position: absolute; inset: 0; display: grid; place-items: center; background: radial-gradient(1200px 600px at 50% -10%, rgba(255,255,255,0.06), transparent 60%); }
    .card { width: min(680px, 92vw); background: rgba(15,18,28,0.9); border: 1px solid var(--panel-strong); border-radius: 24px; padding: 18px 18px 14px; box-shadow: 0 15px 40px rgba(0,0,0,0.45); backdrop-filter: blur(8px); }
    .title { font-size: 28px; font-weight: 800; letter-spacing: 0.2px; margin: 4px 0 12px; }
    .subtitle { opacity: 0.85; line-height: 1.4; font-size: 14px; }
    .actions { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 14px; }
    .btn { all: unset; display: inline-flex; align-items: center; justify-content: center; padding: 12px 16px; border-radius: 16px; background: var(--accent); color: #05131f; font-weight: 800; cursor: pointer; }
    .btn.secondary { background: var(--panel); color: var(--fg); border: 1px solid var(--panel-strong); }
    .btn:active { transform: translateY(1px); }

    /* Treats drag UI */
    #treatTray { position: absolute; bottom: env(safe-area-inset-bottom, 10px); left: 10px; right: 10px; display: flex; gap: 8px; pointer-events: auto; align-items: center; }
    .packet { flex: 0 0 auto; width: 64px; height: 64px; border-radius: 14px; background: linear-gradient(160deg, #1f2937, #0b1220); border: 1px solid var(--panel-strong); display:grid; place-items:center; font-size: 12px; opacity: 0.95; }
    .treat { width: 28px; height: 28px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, #ffd59e, #d97706); box-shadow: 0 8px 16px rgba(0,0,0,0.35); position: absolute; z-index: 20; left: 20px; bottom: 84px; display:none; }
    .hint { font-size: 12px; opacity: 0.8; }

    /* Toast */
    .toast { position: absolute; left: 50%; transform: translateX(-50%); bottom: calc(env(safe-area-inset-bottom, 10px) + 88px); background: rgba(20,24,34,0.9); border:1px solid var(--panel-strong); border-radius: 14px; padding: 8px 12px; font-size: 12px; opacity: 0; transition: opacity .25s ease, transform .25s ease; }
    .toast.show { opacity: 1; transform: translate(-50%, -4px); }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="game">
      <canvas id="scene"></canvas>
      <div class="hud">
        <div class="topbar">
          <div class="bar" title="Time">
            <div id="timeFill" class="fill" style="width:0%"></div>
          </div>
          <div class="chip" style="gap:12px">
            <span style="opacity:.8">Baby</span>
            <div class="bar danger" style="width:120px;">
              <div id="wakeFill" class="fill" style="width:0%"></div>
            </div>
            <button id="pauseBtn">Pause</button>
          </div>
        </div>

        <div id="startOverlay" class="overlay">
          <div class="card">
            <div class="title">Whiskers: Don't Wake the Baby</div>
            <div class="subtitle">
              Swipe to nudge Whiskers. Drag <strong>treats</strong> from the packet into the <strong>bowl</strong> to lure him away.
              Avoid the <strong>bells</strong>. If Whiskers reaches the dangling toy, he'll tumble into the cot and wake the baby.
              Survive the full timer without waking the baby!
            </div>
            <div class="actions">
              <button class="btn" id="startBtn">Start</button>
              <button class="btn secondary" id="howBtn">How to play</button>
            </div>
          </div>
        </div>

        <div id="pauseOverlay" class="overlay" style="display:none;">
          <div class="card">
            <div class="title">Paused</div>
            <div class="subtitle">Swipe to give Whiskers a gentle push. Drop treats into the bowl to distract him.</div>
            <div class="actions">
              <button class="btn" id="resumeBtn">Resume</button>
              <button class="btn secondary" id="restartBtn">Restart</button>
            </div>
          </div>
        </div>

        <div id="endOverlay" class="overlay" style="display:none;">
          <div class="card">
            <div class="title" id="endTitle">Game Over</div>
            <div class="subtitle" id="endMsg">The baby woke up!</div>
            <div class="actions">
              <button class="btn" id="againBtn">Play again</button>
            </div>
          </div>
        </div>

        <div id="treatTray">
          <div class="packet" id="packet">üçó Treats</div>
          <div class="hint">Drag a treat into the bowl (üéØ highlights when close)</div>
        </div>
        <div id="toast" class="toast">Treat added! Whiskers is distracted.</div>
        <div id="treat" class="treat"></div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // ----- Core Setup -----
    const canvas = document.getElementById('scene');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true, powerPreference: 'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0e13);

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0.6, 3.3, 6.2);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.8);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(4,6,3);
    dir.castShadow = true;
    dir.shadow.mapSize.set(1024,1024);
    scene.add(dir);

    const shadowMat = new THREE.ShadowMaterial({ opacity: 0.22 });
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // Floor (nursery rug)
    const floorGeo = new THREE.CylinderGeometry(6.5, 6.5, 0.2, 48);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x101623, metalness: 0.05, roughness: 0.9 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.receiveShadow = true;
    floor.position.y = -0.1;
    scene.add(floor);

    // ----- Low-poly Cot + Toy (goal) -----
    const cot = new THREE.Group();
    const cotBase = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.2, 1.2), new THREE.MeshStandardMaterial({ color: 0x394e6a, metalness: 0.1, roughness: 0.8 }));
    cotBase.castShadow = cotBase.receiveShadow = true;
    cotBase.position.y = 0.6;
    cot.add(cotBase);
    const mattress = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.25, 1.0), new THREE.MeshStandardMaterial({ color: 0xb4e1ff, metalness: 0.0, roughness: 1.0 }));
    mattress.position.y = 0.85; mattress.castShadow = mattress.receiveShadow = true; cot.add(mattress);
    // Rails
    const railMat = new THREE.MeshStandardMaterial({ color: 0x587aa1, metalness: 0.15, roughness: 0.6 });
    for (let i=0;i<10;i++){
      const rail = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,0.9,10), railMat);
      rail.position.set(-1.1 + i*0.24, 1.1, -0.55); rail.castShadow = true; cot.add(rail);
      const rail2 = rail.clone(); rail2.position.z = 0.55; cot.add(rail2);
    }
    const frame = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.1, 1.3), new THREE.MeshStandardMaterial({ color: 0x2b3a52 }));
    frame.position.y = 1.2; frame.material.transparent = true; frame.material.opacity = 0.12; cot.add(frame);
    cot.position.set(0,0, -2.4);
    scene.add(cot);

    // Dangling toy above cot
    const toyGroup = new THREE.Group();
    const string = new THREE.Mesh(new THREE.CylinderGeometry(0.015,0.015,1.2,8), new THREE.MeshStandardMaterial({ color: 0xffffff }));
    string.position.y = 2.2; toyGroup.add(string);
    const star = new THREE.Mesh(new THREE.OctahedronGeometry(0.18,0), new THREE.MeshStandardMaterial({ color: 0xffc34d, emissive: 0x331c00 }));
    star.position.y = 1.6; star.castShadow = true; toyGroup.add(star);
    toyGroup.position.set(0,0,-2.4);
    scene.add(toyGroup);

    // ----- Bowl (lure target) -----
    const bowl = new THREE.Group();
    const bowlOuter = new THREE.Mesh(new THREE.CylinderGeometry(0.36, 0.42, 0.22, 32), new THREE.MeshStandardMaterial({ color: 0xf59e0b, roughness: 0.4 }));
    const bowlInner = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.36, 0.2, 32), new THREE.MeshStandardMaterial({ color: 0x11131a }));
    bowlInner.position.y = 0.02; bowl.add(bowlOuter); bowl.add(bowlInner);
    bowl.position.set(-1.6, 0.11, 1.2);
    bowl.castShadow = bowl.receiveShadow = true;
    scene.add(bowl);

    // ----- Bells (hazards) -----
    const bells = [];
    function makeBell(x,z){
      const g = new THREE.Group();
      const top = new THREE.Mesh(new THREE.SphereGeometry(0.16, 14, 10), new THREE.MeshStandardMaterial({ color: 0xd1d5db, metalness: 0.6, roughness: 0.25 }));
      const lip = new THREE.Mesh(new THREE.TorusGeometry(0.18, 0.035, 10, 24), new THREE.MeshStandardMaterial({ color: 0xe5e7eb, metalness: 0.7, roughness: 0.3 }));
      lip.rotation.x = Math.PI/2;
      const clapper = new THREE.Mesh(new THREE.SphereGeometry(0.06, 10, 8), new THREE.MeshStandardMaterial({ color: 0x9ca3af, metalness: 0.5, roughness: 0.5 }));
      clapper.position.y = -0.05;
      g.add(top); g.add(lip); g.add(clapper);
      g.position.set(x, 0.16, z);
      g.castShadow = true; g.receiveShadow = true;
      scene.add(g);
      bells.push({ g, r: 0.22, woke: false, bumpTime: 0 });
    }
    makeBell(-0.2, -0.6);
    makeBell(1.4, -0.2);
    makeBell(0.9, 1.5);

    // ----- Whiskers (hero) -----
    const whiskers = new THREE.Group();
    // body
    const body = new THREE.Mesh(new THREE.SphereGeometry(0.32, 18, 14), new THREE.MeshStandardMaterial({ color: 0x3f3d56, roughness: 0.9 }));
    body.scale.set(1.4, 1.0, 1.0); body.position.y = 0.35; body.castShadow = true; whiskers.add(body);
    // head
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.22, 18, 14), new THREE.MeshStandardMaterial({ color: 0x4b4a67, roughness: 0.85 }));
    head.position.set(0.22, 0.58, 0); head.castShadow = true; whiskers.add(head);
    // ears
    const earGeo = new THREE.ConeGeometry(0.09, 0.14, 8);
    const ear1 = new THREE.Mesh(earGeo, new THREE.MeshStandardMaterial({ color: 0x5b5a7b })); ear1.position.set(0.3,0.78,0.08); ear1.rotation.z = -0.3; whiskers.add(ear1);
    const ear2 = ear1.clone(); ear2.position.z = -0.08; ear2.rotation.z = 0.3; whiskers.add(ear2);
    // tail
    const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.06, 0.6, 10), new THREE.MeshStandardMaterial({ color: 0x3f3d56 }));
    tail.position.set(-0.45,0.6,0); tail.rotation.z = 1.1; whiskers.add(tail);
    whiskers.position.set(-2.2, 0.05, -1.0);
    whiskers.castShadow = whiskers.receiveShadow = true;
    scene.add(whiskers);

    // Simple shadow catcher circle under Whiskers
    const catShadow = new THREE.Mesh(new THREE.CircleGeometry(0.32, 20), shadowMat);
    catShadow.rotation.x = -Math.PI/2; catShadow.position.set(whiskers.position.x, 0.001, whiskers.position.z); scene.add(catShadow);

    // ----- Game State -----
    const state = {
      running: false,
      over: false,
      time: 0,
      duration: 60, // seconds to survive
      wake: 0, // 0..100
      treatAttract: 0, // frames remaining
      bowlPulse: 0,
      swipe: { start: null, t: 0 },
      v: new THREE.Vector3(0.04, 0, 0.02), // Whiskers velocity
      a: new THREE.Vector3(),
      toyPos: new THREE.Vector3(0, 1.6, -2.4),
    };

    // ----- UI Elements -----
    const startOverlay = document.getElementById('startOverlay');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const endOverlay = document.getElementById('endOverlay');
    const endTitle = document.getElementById('endTitle');
    const endMsg = document.getElementById('endMsg');
    const timeFill = document.getElementById('timeFill');
    const wakeFill = document.getElementById('wakeFill');
    const toast = document.getElementById('toast');

    // Buttons
    document.getElementById('startBtn').onclick = () => start();
    document.getElementById('howBtn').onclick = () => showToast('Swipe to nudge. Drag a treat into the bowl to distract Whiskers.');
    document.getElementById('pauseBtn').onclick = () => pause();
    document.getElementById('resumeBtn').onclick = () => resume();
    document.getElementById('restartBtn').onclick = () => restart();
    document.getElementById('againBtn').onclick = () => restart();

    function showToast(msg){ toast.textContent = msg; toast.classList.add('show'); setTimeout(()=> toast.classList.remove('show'), 1600); }

    // ----- Input: Swipe to nudge -----
    let touchId = null;
    const touchStart = (x,y) => { state.swipe.start = { x, y, t: performance.now() }; };
    const touchEnd = (x,y) => {
      if (!state.swipe.start) return;
      const dx = x - state.swipe.start.x;
      const dy = y - state.swipe.start.y;
      const dt = Math.max(1, performance.now() - state.swipe.start.t);
      const speed = Math.hypot(dx,dy) / dt; // px per ms
      if (speed > 0.5) { // quick swipe
        // Map screen swipe to world XZ impulse relative to camera
        const angle = Math.atan2(dx, dy); // screen coords: up is negative y
        const strength = Math.min(0.18, speed * 0.22);
        // Convert angle to world XZ (camera facing -Z)
        const impulse = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle)).multiplyScalar(strength);
        state.v.add(impulse);
        pulseWhiskers();
      }
      state.swipe.start = null;
    };

    canvas.addEventListener('touchstart', (e)=>{ if (!state.running) return; const t = e.changedTouches[0]; touchId = t.identifier; touchStart(t.clientX, t.clientY); }, {passive:true});
    canvas.addEventListener('touchend', (e)=>{ if (!state.running) return; const t = [...e.changedTouches].find(t=>t.identifier===touchId); if (t) touchEnd(t.clientX, t.clientY); }, {passive:true});
    canvas.addEventListener('mousedown', (e)=>{ if (!state.running) return; touchStart(e.clientX, e.clientY); });
    window.addEventListener('mouseup', (e)=>{ if (!state.running) return; touchEnd(e.clientX, e.clientY); });

    function pulseWhiskers(){
      whiskers.scale.set(1.02,1.02,1.02);
      setTimeout(()=> whiskers.scale.set(1,1,1), 120);
    }

    // ----- Drag Treats into Bowl -----
    const packet = document.getElementById('packet');
    const treat = document.getElementById('treat');
    let dragging = false;

    function screenPosOf(obj){
      const v = obj.position.clone();
      obj.getWorldPosition(v);
      v.project(camera);
      const x = (v.x * 0.5 + 0.5) * innerWidth;
      const y = (-v.y * 0.5 + 0.5) * innerHeight;
      return { x, y };
    }

    function spawnTreat(){
      const rect = packet.getBoundingClientRect();
      treat.style.left = (rect.left + rect.width/2 - 14) + 'px';
      treat.style.top = (rect.top - 38) + 'px';
      treat.style.display = 'block';
      dragging = true;
    }

    function endTreatDrag(x, y){
      if (!dragging) return;
      dragging = false; treat.style.display = 'none';
      const b = screenPosOf(bowl);
      const d = Math.hypot(x - b.x, y - b.y);
      if (d < 80) { // success
        state.treatAttract = 6 * 60; // frames (~6s)
        state.bowlPulse = 60;
        showToast('Treat added! Whiskers is distracted.');
      } else {
        showToast('Missed the bowl. Try again.');
      }
    }

    function moveTreat(x,y){ if (!dragging) return; treat.style.left = (x-14)+'px'; treat.style.top = (y-14)+'px'; }

    packet.addEventListener('touchstart', (e)=>{ e.preventDefault(); spawnTreat(); }, {passive:false});
    window.addEventListener('touchmove', (e)=>{ if(!dragging) return; const t=e.touches[0]; moveTreat(t.clientX, t.clientY); }, {passive:true});
    window.addEventListener('touchend', (e)=>{ const t=e.changedTouches[0]; endTreatDrag(t.clientX, t.clientY); }, {passive:true});
    packet.addEventListener('mousedown', (e)=>{ e.preventDefault(); spawnTreat(); });
    window.addEventListener('mousemove', (e)=> moveTreat(e.clientX, e.clientY));
    window.addEventListener('mouseup', (e)=> endTreatDrag(e.clientX, e.clientY));

    // ----- Helpers -----
    function clamp(v, a, b){ return Math.min(b, Math.max(a, v)); }
    function distXZ(a,b){ return Math.hypot(a.x-b.x, a.z-b.z); }

    // ----- Game Flow -----
    function start(){
      startOverlay.style.display = 'none';
      endOverlay.style.display = 'none';
      state.running = true; state.over = false; state.time = 0; state.wake = 0; state.treatAttract = 0;
    }
    function pause(){ if(!state.running) return; state.running = false; pauseOverlay.style.display = 'grid'; }
    function resume(){ state.running = true; pauseOverlay.style.display = 'none'; }
    function restart(){
      // reset positions
      whiskers.position.set(-2.2, 0.05, -1.0); state.v.set(0.04,0,0.02);
      bells.forEach(b=>{ b.woke=false; });
      bowl.position.set(-1.6, 0.11, 1.2);
      start();
    }

    // ----- Core Update Loop -----
    const tmp = new THREE.Vector3();
    function update(dt){
      if (!state.running || state.over) return;

      // timer
      state.time += dt; const t = clamp(state.time / state.duration, 0, 1); timeFill.style.width = (t*100).toFixed(1)+'%';
      if (state.time >= state.duration){ return win(); }

      // Attraction: treat vs toy
      const target = tmp.set(0,0,0);
      if (state.treatAttract > 0){
        const bp = new THREE.Vector3(); bowl.getWorldPosition(bp); target.copy(bp);
        state.treatAttract--; if (state.bowlPulse>0) state.bowlPulse--;
      } else { target.set(state.toyPos.x,0,state.toyPos.z); }

      // Simple steering towards target with slight wander
      const cat = whiskers.position;
      const desired = tmp.set(target.x - cat.x, 0, target.z - cat.z).normalize().multiplyScalar(0.06);
      // Add wander
      desired.x += (Math.sin(performance.now()*0.002) * 0.008);
      desired.z += (Math.cos(performance.now()*0.0017) * 0.008);
      state.a.copy(desired).sub(state.v).multiplyScalar(0.12);
      state.v.add(state.a);
      // friction
      state.v.multiplyScalar(0.992);
      // move
      cat.add(state.v);
      catShadow.position.set(cat.x, 0.001, cat.z);

      // Bounds bounce
      const r = 6.2; const d = Math.hypot(cat.x, cat.z);
      if (d > r){ state.v.multiplyScalar(-0.6); whiskers.position.set(cat.x*(r/d), cat.y, cat.z*(r/d)); }

      // Bells collision
      for (const b of bells){
        const p = b.g.position; const dd = distXZ(p, cat);
        if (dd < b.r + 0.25){
          // bounce away and wake increase
          const away = tmp.set(cat.x-p.x,0,cat.z-p.z).normalize().multiplyScalar(0.08);
          state.v.add(away);
          if (!b.woke){
            bumpWake(10); b.woke = true; b.bumpTime = 32; setTimeout(()=> b.woke=false, 1200);
          }
        }
        // tiny bell jiggle visual
        if (b.bumpTime>0){ b.g.rotation.z = Math.sin(performance.now()*0.04)*0.15; b.bumpTime--; } else { b.g.rotation.z *= 0.9; }
      }

      // Reach toy? -> fall into cot -> lose
      const toyXZ = new THREE.Vector3(state.toyPos.x,0,state.toyPos.z);
      const dToy = distXZ(cat, toyXZ);
      if (dToy < 0.4){
        return lose('Whiskers reached the toy and fell into the cot! The baby woke up.');
      }

      // Bowl pulse effect
      bowl.scale.setScalar(1 + (state.bowlPulse>0 ? Math.sin(performance.now()*0.02)*0.06+0.1 : 0));

      // Head look-at target
      head.lookAt(target.x, head.position.y, target.z);
    }

    function bumpWake(amount){ state.wake = clamp(state.wake + amount, 0, 100); wakeFill.style.width = state.wake+'%'; if (state.wake >= 100){ lose('The bells rang too much and the baby woke up!'); } }

    function win(){ state.running=false; state.over=true; endTitle.textContent='You did it!'; endMsg.textContent='You kept the baby asleep for the whole timer. Nicely done.'; endOverlay.style.display='grid'; }
    function lose(msg){ state.running=false; state.over=true; endTitle.textContent='Game Over'; endMsg.textContent=msg; endOverlay.style.display='grid'; }

    // ----- Render Loop -----
    let last = performance.now();
    function loop(){
      const now = performance.now();
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;
      update(dt);
      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    loop();

    // ----- Resize -----
    function onResize(){
      const w = innerWidth, h = innerHeight;
      camera.aspect = w/h; camera.updateProjectionMatrix();
      renderer.setSize(w,h);
    }
    addEventListener('resize', onResize);

    // Start in idle state
  </script>
</body>
</html>
